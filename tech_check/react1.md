# React 

1. [Що таке React і в чому полягають його переваги?](#що-таке-react-і-в-чому-полягають-його-переваги)

2. [Чи можна до вже існуючого сайту підключити лише один новий компонент на React? Як?](#чи-можна-до-вже-існуючого-сайту-підключити-лише-один-новий-компонент-на-react-як)

3. [Що таке JSX? Який у нього синтаксис?](#що-таке-jsx-який-у-нього-синтаксис)

4. [Чи обов’язково використовувати JSX із Реактом?](#чи-обовязково-використовувати-jsx-із-реактом)

5. [Що таке Virtual DOM?](#що-таке-virtual-dom)

6. [Що таке компонент і в чому різниця між компонентом-функцією та компонентом-класом? У чому відмінність між компонентом та JSX-елементом?](#що-таке-компонент-і-в-чому-різниця-між-компонентом-функцією-та-компонентом-класом-у-чому-відмінність-між-компонентом-та-jsx-елементом)

7. [Що таке props? Як отримати до них доступ і як їх поміняти?](#що-таке-props-як-отримати-до-них-доступ-і-як-їх-поміняти)

8. [Що таке state? Як отримати до нього доступ і як його поміняти?](#що-таке-state-як-отримати-до-нього-доступ-і-як-його-поміняти)

9. [Які є методи життєвого циклу React-компонента?](#які-є-методи-життєвого-циклу-react-компонента)

10. [Як користуватися методом componentDidMount і для чого він потрібен?](#як-користуватися-методом-componentdidmount-і-для-чого-він-потрібен)

11. [Як користуватися методом componentDidUpdate і для чого він потрібен?](#як-користуватися-методом-componentdidupdate-і-для-чого-він-потрібен)

12. [Як користуватися методом componentWillUnmount і для чого він потрібен?](#як-користуватися-методом-componentwillunmount-і-для-чого-він-потрібен)

13. [Як можна навісити подію на JSX-компонент? Чи можна навішувати події на компоненти?](#як-можна-навісити-подію-на-jsx-компонент-чи-можна-навішувати-події-на-компоненти)

14. [Результат яких типів може повертати метод render (або компонент-функція)?](#результат-яких-типів-може-повертати-метод-render-або-компонент-функція)

15. [У яких випадках потрібно присвоювати елементам та/або компонентам атрибут key? Яке значення слід присвоювати цьому атрибуту? Для чого він потрібен?](#у-яких-випадках-потрібно-присвоювати-елементам-таабо-компонентам-атрибут-key-яке-значення-слід-присвоювати-цьому-атрибуту-для-чого-він-потрібен)

16. [Для чого потрібен PropTypes і які види перевірок у ньому доступні?](#для-чого-потрібен-proptypes-і-які-види-перевірок-у-ньому-доступні)

17. [Що таке властивість children?](#що-таке-властивість-children)

18. [Як можна оптимізувати рендеринг компонентів? (keys, shouldComponentUpdate, PureComponent, React.memo)](#як-можна-оптимізувати-рендеринг-компонентів-keys-shouldcomponentupdate-purecomponent-reactmemo)

19. [Що таке мемоізація?](#що-таке-мемоізація)

## Що таке React і в чому полягають його переваги?

**ReactJS** — це **декларативна, ефективна та гнучка бібліотека JavaScript для створення повторно використовуваних компонентів інтерфейсу користувача**.
 
Це компонентна інтерфейсна бібліотека з відкритим кодом, яка відповідає лише за рівень перегляду програми. 

Його створив Джордан Уолк, який був інженером-програмістом у **Facebook**. Спочатку він був розроблений і підтримувався Facebook, а пізніше використовувався в таких продуктах, як **WhatsApp** і **Instagram**.

Основні особливості React:

1. Використовує синтаксис **JSX**, розширення синтаксису JS, яке дозволяє розробникам писати **HTML** у коді **JS**.

2. Він використовує **VirtualDOM** замість **RealDOM**, враховуючи, що маніпуляції з RealDOM дорогі.

3. Підтримує **рендеринг на стороні сервера**.

3. Слідкує за **односпрямованим (Unidirectional) потоком даних або прив’язкою даних**.

4. Використовує **компоненти інтерфейсу користувача**, які можна **багаторазово використовувати**, для розробки подання.

[Video](https://youtu.be/ULRIWUsT86U)

[Back to top](#react)

## Чи можна до вже існуючого сайту підключити лише один новий компонент на React? Як?

### Крок 1. Додайте контейнер DOM до HTML

Спочатку відкрийте сторінку HTML, яку потрібно редагувати. Додайте порожній тег `div`, щоб позначити місце, де ви хочете відобразити щось за допомогою React.

Ми надали цьому `div` унікальний атрибут HTML `id`. Це дозволить нам пізніше знайти його в коді JavaScript і відобразити в ньому компонент React.
``` html
<body>
    <div id="root"></div>
</body>
```

### Крок 2: Додайте теги script

Далі додайте **три теги сценарію** на сторінку HTML безпосередньо перед закриваючим тегом `/body`.

``` html 
<script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>

<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>

<script src="component.js"></script>
```

### Крок 3: Створіть компонент React
1. Class component
``` js
import React from 'react';

type State = {
  title: string;
  users: User[];
  selectedUser: User | null;
};

type Props = {
  todos: Todo[];
  onAdd: (title: string) => void;
};

class Counter extends React.Component<Props, State> {

  // explicit state type tells TS that `selectedUser` can be a `User` not only `null`
  state: Readonly<State> = { 
    title: '',
    users: [],
    selectedUser: null,
  };
  
  componentDidMount() {
    // users must be User[] not number[]
    this.setState({ users: [1, 2, 3] }); // type error
  
    // Readonly<State> protects you from making a mutation
    this.state.title = 'Hello'; // type error
  }
  
  render() {
    const { title, users, selectedUser } = this.state;
    
    return 'Your markup';
  }
}
```
2. Functional component
``` js
import React from 'react';

const App: React.FC = () => (
  <div className="App">
    <UsersList users={usersFromServer} />
  </div> 
);

type Props = {
  users: User[];
};

const UsersList: React.FC<Props> = ({ users }) => (
  <h1>Your markup</h1>
);
```

### Крок 4: Додайте DOM рендер
``` js
import ReactDOM from 'react-dom';
import { App } from './App';

ReactDOM.render(
  <App />,
  document.getElementById('root'),
);
```

[Video](https://youtu.be/TfejHJq1SKo)

[Link](https://rajdeep-das.medium.com/how-to-add-react-to-an-existing-website-or-web-project-11b598f989d3)

[Back to top](#react)

## Що таке JSX? Який у нього синтаксис?

**JSX** — це **XML-подібне синтаксичне розширення ECMAScript** (акронім означає JavaScript XML). По суті, він просто забезпечує **синтаксичний цукор для функції React.createElement(), надаючи нам виразність JavaScript разом із синтаксисом HTML, схожим на шаблон**.

У наведеному нижче прикладі текст усередині тегу `h1` повертається як функція JavaScript до функції `render`.
``` jsx
export default function App() {
  return (
    <div>
      <h1>{"Welcome to React world!"}</h1>
    </div>
  );
}
```
[Video](https://www.youtube.com/watch?v=J0OPTvIw7fs)

[Back to top](#react)

## Чи обов’язково використовувати JSX із Реактом?

JSX **не** є вимогою для роботи з React. **Використання React без JSX є найзручнішим тоді, коли ви не бажаєте налаштовувати компіляцію у вашому середовищі збірки.**

Кожен JSX-елемент являє собою “синтаксичний цукор” для виклику `React.createElement(component, props, ...children)`. Отже, все що можна зробити за допомогою JSX, може також бути виконаним на чистому JavaScript.
``` jsx
// JSX
class Hello extends React.Component {
  render() {
    return <div>Привіт,  {this.props.toWhat}</div>;
  }
}

ReactDOM.render(
  <Hello toWhat="світе" />,
  document.getElementById('root')
);
```

``` js
// JS
class Hello extends React.Component {
  render() {
    return React.createElement('div', null, `Привіт, ${this.props.toWhat}`);
  }
}

ReactDOM.render(
  React.createElement(Hello, {toWhat: 'світе'}, null),
  document.getElementById('root')
);
```

[Documentation](https://uk.reactjs.org/docs/react-without-jsx.html)

[Back to top](#react)

## Що таке Virtual DOM?

**Віртуальний DOM (VDOM)** - це **концепція програмування**, в якій **«віртуальне» представлення інтерфейсу користувача зберігається в пам’яті і синхронізується зі «справжнім» DOM** за допомогою бібліотеки, такої як ReactDOM. Цей процес називається **узгодженням (reconciliation)**.

Це **дерево вузлів**, у якому перераховані **елементи**, їхні **атрибути** та **content** як **об’єкти** та їхні **властивості**. Функція рендерингу React створює дерево вузлів із **компонентів** React. Потім він **оновлює** це дерево у відповідь на **мутації в моделі даних**, спричинені різними діями, які виконує користувач або система.

Однак, React також використовує **внутрішні об’єкти**, так звані **«волокна» (fibers)** для зберігання **додаткової інформації про дерево компонентів**. Вони також можуть вважатися частиною реалізації «віртуального DOM» в React.

Virtual DOM працює в три прості кроки.

1. Щоразу, коли будь-які базові **дані змінюються**, весь інтерфейс користувача **повторно відображається у представленні Virtual DOM**.

2. Потім обчислюється **різниця** між **попереднім** представленням DOM і **новим**.

3. Після завершення обчислень **реальний DOM** буде оновлено лише тими речами, які **фактично змінилися**.

[Video](https://www.youtube.com/watch?v=TCwoDZnpdKs)

[Documentation](https://uk.reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom)

[Back to top](#react)

## Що таке компонент і в чому різниця між компонентом-функцією та компонентом-класом? У чому відмінність між компонентом та JSX-елементом?

**Елемент** — це **звичайний об’єкт**, який описує те, що ви хочете відобразити на екрані, у вигляді **вузлів DOM або інших компонентів**.

Елементи можуть містити інші елементи у своїх атрибутах. Після створення елемента він **ніколи не змінюється.**
``` jsx
const element = React.createElement("div", { id: "login-btn" }, "Login");
```

Наведена вище функція `React.createElement()` повертає **об’єкт**:
``` json
{
  type: 'div',
  props: {
    children: 'Login',
    id: 'login-btn'
  }
}
```

І, нарешті, він **рендериться в DOM** за допомогою `ReactDOM.render()`:
``` html
<div id="login-btn">Login</div>
```

Концептуально **компоненти** є подібними до **функцій JavaScript**. Вони **приймають** довільні вхідні дані (так звані **“пропси”**) і **повертають React-елементи**, що описують те, що повинно з’явитися на екрані.

Компоненти є **будівельними блоками інтерфейсу користувача**. Ці компоненти **розбивають інтерфейс користувача на невеликі незалежні частини**, які можна **багаторазово використовувати**. Потім він робить кожен із цих компонентів незалежним один від одного, не впливаючи на решту інтерфейсу користувача.

Компонент може бути оголошений кількома різними способами. Це може бути **клас** із методом `render()` або його можна визначити як **функцію**. У будь-якому випадку він приймає **властивості як вхідні дані** та повертає **дерево JSX як вихідні дані**.

1. Functional component
``` jsx
import React from 'react';

const App: React.FC = () => (
  <div className="App">
    <UsersList users={usersFromServer} />
  </div> 
);

type Props = {
  users: User[];
};

const UsersList: React.FC<Props> = ({ users }) => (
  <h1>Your markup</h1>
);
```

2. Class component
``` jsx
import React from 'react';

type State = {
  title: string;
  users: User[];
  selectedUser: User | null;
};

type Props = {
  todos: Todo[];
  onAdd: (title: string) => void;
};

class Counter extends React.Component<Props, State> {

  // explicit state type tells TS that `selectedUser` can be a `User` not only `null`
  state: Readonly<State> = { 
    title: '',
    users: [],
    selectedUser: null,
  };
  
  componentDidMount() {
    // users must be User[] not number[]
    this.setState({ users: [1, 2, 3] }); // type error
  
    // Readonly<State> protects you from making a mutation
    this.state.title = 'Hello'; // type error
  }
  
  render() {
    const { title, users, selectedUser } = this.state;
    
    return 'Your markup';
  }
}
```

[Video](https://www.youtube.com/watch?v=968t8jEriC4)

[Documentation](https://uk.reactjs.org/docs/components-and-props.html)

[Back to top](#react)

## Що таке props? Як отримати до них доступ і як їх поміняти?

**Props** — це скорочення `Properties` у React. Додаткові параметри, які ми передаємо в React компонент. Це компоненти `readonly`, які мають бути чистими, тобто **immutable**. Вони завжди передаються від батьківського до дочірнього компонента протягом усієї програми. **Дочірній компонент ніколи не може надіслати проп назад до батьківського компонента.** Це допомагає підтримувати односпрямований потік даних і зазвичай використовується для відтворення динамічно згенерованих даних.
Class: `this.props`
Functional component: `props`

[Video](https://youtu.be/ahLrInl0dRM)

[Back to top](#react)

## Що таке state? Як отримати до нього доступ і як його поміняти? 

'State' - це внутрішній стан компонента, спеціальний обєкт, який зберігається в компоненті (*лише в класових компонентах*).

Компонент потребує `state`, коли **якісь дані в ньому змінюються з часом**. Наприклад, компоненту `Checkbox` може знадобитися `isChecked` у його стані, а компонент `NewsFeed` має відслідковувати `fetchedPosts` у своєму стані.

Найбільша різниця між `state` і `props` полягає в тому, що `props` передаються з **батьківського компонента**, а `state` керується **самим компонентом**. Компонент **не може змінювати** власні `props`, але **може змінювати** `state`.

Модифікація state за допомогою `setState()`.

[Video](https://youtu.be/LeC2VDCVBr4)

[Back to top](#react)

## Які є методи життєвого циклу React-компонента?

Життєвий цикл компонента має три окремі фази життєвого циклу:

1. **Mounting (встановлення)**: компонент готовий до монтування в `DOM` браузера. Цей етап охоплює ініціалізацію з методів життєвого циклу `constructor()`, `getDerivedStateFromProps()`, `render()` і `componentDidMount()`.

2. **Updating (оновлення)**: на цьому етапі компонент оновлюється двома способами, **надсилаючи нові властивості** та оновлюючи стан за допомогою `setState()` або `forceUpdate()`. Цей етап охоплює методи життєвого циклу `getDerivedStateFromProps()`, `shouldComponentUpdate()`, `render()`, `getSnapshotBeforeUpdate()` і `componentDidUpdate()`.

3. **Unmounting (видалення)**: на цьому останньому етапі компонент не потрібний і демонтується з DOM браузера. Цей етап включає метод життєвого циклу `componentWillUnmount()`.

![Lifecycle](../assets/img/phases16.4.png)

[Video](https://youtu.be/nTp2E7ap3-M)

[Back to top](#react)

## Як користуватися методом componentDidMount і для чого він потрібен?

`componentDidMount`: виконується **після першого рендерингу**, і тут мають відбуватися всі запити `AJAX`, `DOM` або оновлення стану та налаштування `event listeners`.

Ці дії не потрібно робити в конструкторі, бо тоді вони можуть розпочатися раніше, ніж компонент з'явиться на сторінці.

`getDerivedStateFromProps`: викликається безпосередньо **перед викликом** `render()` і викликається **під час кожного рендеру**. Це існує для рідкісних випадків використання, коли вам потрібен **похідний (derived)** `state`.

[Video](https://youtu.be/lXvdQxrXFFM)

[Back to top](#react)

## Як користуватися методом componentDidUpdate і для чого він потрібен?

`componentDidUpdate`: Здебільшого він використовується для **оновлення DOM** у відповідь на зміни `props` або `state`. Це не запускатиметься, якщо `shouldComponentUpdate()` повертає `false`.Виконується **після кожного рендеру**, тому важливо **робити перевірку чи змінилися вхідні дані (пропси)**.

`shouldComponentUpdate`: визначає, чи буде компонент оновлено чи ні. За замовчуванням він повертає `true`. Якщо ви впевнені, що компонент не потребує візуалізації після оновлення стану чи атрибутів, ви можете повернути `false` значення. Це чудове місце для покращення продуктивності, оскільки воно дозволяє запобігти повторному рендерингу, якщо компонент отримує нову пропозицію.

`getSnapshotBeforeUpdate`: виконується **безпосередньо перед тим, як відтворений результат буде зафіксовано в DOM**. Будь-яке значення, повернуте ним, буде передано в `componentDidUpdate()`. Це корисно для захоплення інформації з DOM, тобто позиції прокручування.

[Video](https://youtu.be/eW47sBXCLro)

[Back to top](#react)

## Як користуватися методом componentWillUnmount і для чого він потрібен? 

`componentWillUnmount`: він використовуватиметься для скасування будь-яких вихідних мережевих запитів або **видалення всіх прослуховувачів подій, пов’язаних із компонентом**. 

Потрібен для відміни глобальних підписок (resize, scroll), бо при видаленні компонентів зі сторінки таймери не зупиняються, що може погано вплинути на продуктивність.

[Video](https://youtu.be/Eo3fMhNeSqk)

[Back to top](#react)

## Як можна навісити подію на JSX-компонент? Чи можна навішувати події на компоненти? 

`Handling events` можна додавати на **DOM елемент**и, але **не** на компоненти. Будь-яка функція, передана в компонент вважаєтьмя **кастомною властивістю**.

Обробка подій для React-елементів дуже схожа до обробки подій для DOM-елементів. Але є деякі синтаксичні відмінності:

* Події React іменуються в `camelCase`, а не в нижньому регістрі.

* З JSX ви передаєте **функцію як обробник події замість рядка**.

* Ви не можете повернути `false` для того, щоб запобігти поведінці за замовчуванням у React. Ви маєте явно викликати `preventDefault`. 
``` jsx
function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log('Посилання було натиснуте.');
  }

  return (
    <a href="#" onClick={handleClick}>
      Натисни на мене
    </a>
  );
}
```

Тут `e` - це **синтетична подія**. React визначає ці синтетичні події відповідно до *специфікації W3C*, тому вам не потрібно турбуватися про сумісніть між браузерами. React-події працюють інакше, ніж нативні події. 

`SyntheticEvent` — це **кросбраузерна оболонка рідної події браузера**. Його API такий самий, як і власна подія браузера, включаючи `stopPropagation()` і `preventDefault()`, за винятком того, що **події працюють однаково в усіх браузерах**.

[Video](https://youtu.be/WvwlcGQL0vM)

[Back to top](#react)

## Результат яких типів може повертати метод render (або компонент-функція)?

Нижче наведено список наступних типів, що використовуються, і повертаються з методу `render`,

1. **Елементи React**: елементи, які наказують React відобразити вузол DOM. Він включає елементи `html`, такі як `<div/>` та визначені користувачем елементи.

2. **Масиви та фрагменти**: повертає кілька елементів для візуалізації як масиви та фрагменти для обгортання кількох елементів.

3. **Портали**: візуалізація дітей в інше піддерево DOM.

4. **Рядки та числа**: візуалізуйте рядки та числа як текстові вузли в DOM.

5. **Booleans/null**: нічого не відтворює, але ці типи використовуються для умовного відтворення вмісту.

[Video](https://youtu.be/6FAGP5IhyvI)

[Back to top](#react)

## У яких випадках потрібно присвоювати елементам та/або компонентам атрибут key? Яке значення слід присвоювати цьому атрибуту? Для чого він потрібен?

`Key` — це **спеціальний атрибут** `string`, який слід додати під час створення масивів елементів. `Key prop` **допомагає React визначити, які елементи змінено, додано чи видалено.**

Найчастіше ми використовуємо ID з наших даних як ключ:
``` jsx
const todoItems = todos.map((todo) => <li key={todo.id}>{todo.text}</li>);
```
* **Не рекомендується** використовувати **індекси** для ключів, **якщо порядок елементів може змінитися**. Це може негативно вплинути на продуктивність і спричинити проблеми зі станом компонентів.

* Якщо ви вилучаєте елемент списку як окремий компонент, тоді застосовуйте `keys` до компонента списку замість тегу `li`.

* У консолі з’явиться попередження, якщо параметр `key` відсутній в елементах списку.

Ключі мають бути **стабільними, передбачуваними та унікальними**, щоб React міг відстежувати елементи.

У наведеному нижче фрагменті коду ключ кожного елемента базуватиметься на порядку, а не на даних, які представлено. Це обмежує оптимізацію, яку може зробити React.
``` jsx
{
  todos.map((todo, index) => <Todo {...todo} key={index} />);
}
```

Якщо ви використовуєте дані елемента для унікального `key`, припускаючи, що `todo.id` є унікальним для цього списку та стабільним, React зможе змінити порядок елементів без потреби їх повторно оцінювати.
``` jsx
{
  todos.map((todo) => <Todo {...todo} key={todo.id} />);
}
```

[Video](https://youtu.be/xf1Cv-AEQ8c)

[Back to top](#react)

## Для чого потрібен PropTypes і які види перевірок у ньому доступні?

Для виконання **перевірки типів пропсів** ви можете присвоїти спеціальну властивість `propTypes` компоненту.

`PropTypes` експортує ряд **валідаторів**, які можуть бути використані щоб впевнитись, що ви отримали вірні дані. З міркувань продуктивності `propTypes` перевіряються лише в режимі розробки. Обов’язкові властивості визначаються за допомогою `isRequired`.

Властивість `defaultProps` гарантує, що `this.props.name` матиме значення, навіть якщо воно не було задане батьківським компонентом. Перевірка типів `propTypes` відбувається після застосування `defaultProps`, тобто вона також буде застосована для `defaultProps`.

Якщо ви хочете передати масив об’єктів до компонента з певною формою, використовуйте `React.PropTypes.shape()` як аргумент `React.PropTypes.arrayOf()`.
``` jsx
ReactComponent.propTypes = {
  arrayWithShape: React.PropTypes.arrayOf(
    React.PropTypes.shape({
      color: React.PropTypes.string.isRequired,
      fontSize: React.PropTypes.number.isRequired,
    })
  ).isRequired,
};
```

[Video](https://youtu.be/OIiDTw3L068)

[Documentation](https://uk.reactjs.org/docs/typechecking-with-proptypes.html#gatsby-focus-wrapper)

[Back to top](#react)

## Що таке властивість children?

`Children` — це проп (`this.props.children`), який дозволяє **передавати компоненти як дані іншим компонентам**, як і будь-який інший проп, який ви використовуєте. Дерево компонентів, розміщене між відкриваючим і закриваючим тегами компонента, буде передано цьому компоненту як дочірню властивість.

В React API доступно кілька методів для роботи з цим пропом. До них належать `React.Children.map`, `React.Children.forEach`, `React.Children.count`, `React.Children.only`, `React.Children.toArray`.
``` jsx
const MyDiv = React.createClass({
  render: function () {
    return <div>{this.props.children}</div>;
  },
});

ReactDOM.render(
  <MyDiv>
    <span>{"Hello"}</span>
    <span>{"World"}</span>
  </MyDiv>,
  node
);
```

[Video](https://youtu.be/DUHqTwH1Yec)

[Back to top](#react)

## Як можна оптимізувати рендеринг компонентів? (keys, shouldComponentUpdate, PureComponent, React.memo)

### `keys`

Ключі допомагають React визначити, які елементи змінено, додано чи видалено. Ключі повинні бути надані елементам всередині масиву, щоб надати елементам стабільну ідентичність.

Ми не рекомендуємо використовувати індекси для ключів, якщо порядок елементів може змінитися. Це може негативно вплинути на продуктивність і спричинити проблеми зі станом компонентів.

### `shouldComponentUpdate`

`shouldComponentUpdate`: визначає, чи буде компонент оновлено чи ні. За замовчуванням він повертає `true`. Якщо ви впевнені, що компонент не потребує візуалізації після оновлення стану чи атрибутів, ви можете повернути `false` значення. Це чудове місце для покращення продуктивності, оскільки воно дозволяє запобігти повторному рендерингу, якщо компонент отримує нову пропозицію.

### `PureComponent`

`React.PureComponent` точно такий же, як `React.Component`, за винятком того, що він обробляє метод `shouldComponentUpdate()`. 

Коли `props` або `state` змінюються, `PureComponent` зробить **неглибоке порівняння** як `props`, так і `state`. Компонент, з іншого боку, не порівнюватиме поточні `props` та `state` із наступними. Таким чином, компонент буде повторно рендеритися за замовчуванням щоразу, коли викликається `shouldComponentUpdate`.

### `React.memo`

У функціональних компонентах ми використовуємо `React.memo()` API. `React.memo()` є **компонентом вищого порядку**. Він приймає **компонент React** як свій перший аргумент і повертає спеціальний тип компонента React, який **дозволяє рендереру відтворювати компонент, запам’ятовуючи результат**. Тому, якщо `props` компонента поверхнево рівні, можна використати компонент `React.memo()`.

Якщо ваш компонент рендерить той самий результат із однаковими характеристиками, ви можете загорнути його у виклик `React.memo` для підвищення продуктивності в деяких випадках, запам’ятовуючи результат. Це означає, що React пропустить рендеринг компонента та повторно використає останній відрендерений результат.

[Back to top](#react)

## Що таке мемоізація?

**Мемоізація** — це техніка оптимізації для прискорення комп’ютерних програм шляхом **кешування результатів важких викликів функцій і повернення їх, коли подібні вхідні дані зустрічаються неодноразово**. React мемоізація схожа на кешування.

Коли `props` у **функціональному компоненті** React змінюються, весь компонент `rerender` за замовчуванням. Іншими словами, якщо значення всередині компонента змінюється, весь компонент буде повторно `render` разом із усіма функціями чи компонентами, чиї значення чи властивості не змінилися.

Це призведе до зниження продуктивності, цього можна уникнути за допомогою мемоізації.

1. `React.PureComponent` допомагає нам реалізувати мемоізацію в **компоненті класу**. `PureComponent` реалізує `React.ShouldComponentUpdate()`, який виконує неглибоке порівняння `state` та `props` і рендерить компонент React, лише якщо атрибути або стан змінилися.

2. `React.memo()` дуже простий у використанні, оскільки він ідентичний `React.PureComponent`. Тоді як `React.memo()`працює з **функціональними компонентами**, PureComponent працює з компонентами класу.

3. У React хук `useMemo()` є найбільш фундаментальним методом мемоізації. Щоб використовувати `useMemo()`, передайте **функцію, яка виконує важкі обчислення**, які ви хочете запам’ятати, як **перший параметр** і **масив усіх залежностей** для цього запам’ятовування як **другий аргумент**. `useMemo()` підвищує продуктивність, перераховуючи мемоізоване значення, **лише якщо змінюється одна з заданих залежностей**.

4. `useCallback()` майже еквівалентний `useMemo()` у тому, що він запам’ятовує результат, спираючись на масив залежностей. Однак `useCallback()` використовується лише для запам’ятовування **функцій**, а не значень.

[Video](https://youtu.be/7T-_Dpu0X10)
[Article](https://www.syncfusion.com/blogs/post/what-is-memoization-in-react.aspx#:~:text=Memoization%20is%20an%20optimization%20technique,memoization%20is%20similar%20to%20caching.)

[Back to top](#react)